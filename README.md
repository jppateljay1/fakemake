# fakemake
The program mimics the behavior of the UNIX make program
/*
 * Jay Patel
 * file://readme.txt
 */
filenames in this directory for test cases: exaple, trivial, try, simple
Type "make fakemake" to compile
./fakemake [filename] to run the program
type "?" to see available commands and follow on screen procedures

The program detects repeated by itself before actually running it to avoid later problems.

Other sanity checkers have been added to eliminate any errors within the program. For example, if you try to make a basic file, it will print out an error. Also, if you have a basic file with in the dependency, it will also check that as well.
For example: let's say we have this makefile for example
	hmap.c
	hmap.h
	util.c
	util.o : util.c util.h
	hmap.o : hmap.c hmap.h

This will result in an error, because "util.h" does not actually exist.

It will also detect if you are trying to add a dependency that has already been used.
For example: let's say we have this makefile for example
	hmap.c
	hmap.h
	util.c
	util.o : util.c util.h
	util.o : hmap.c hmap.h

This will result in an error as well since "util.o" is being used twice.

It will also detect an error when you are trying to make a file that does not exist. So, from the previous example, if you try make util.c, it will result in an error saying that you are trying to make a basic file, which is not allowed.

Also, from the above example, if you try to make sum.o, it will result in an error, since "sum.o" does not even exist.

Each line of the input file corresponds to a specific “file” There are two types of files:
Basic files: these are files that are depend on no other files. Think of .c and .h files as in the
above example.
For simplicity, these files are listed one-per-line at the beginning of the file (before all com- posite files - see below).
Target files: these are files that are “constructed” from other files.
Think .o files or executables as in the above example. Or from the expand project, the given
.txt files would be basic and the file generated by expansion would be composite.

In a correclty formatted input, all target files follow basic files, one per line. Since they are constructed from other files, they depend on those files.
These dependencies are listed on the same line with the target file after a colon ’:’. For simplicity, in a correctly formatted file, there will be whitespace between the target file name and the colon and whitespace between the colon and the dependency list (which technically could be empty).

Time Stamps/Being Up To Date
Each file in a system has a time stamp – the last time the file was written. Your program will keep track of time stamps as simple integers.
The time stamps determine whether or not a file is “up to date.” The rules for a file being up to date are as follows:
A basic file is always up to date since it doesn’t depend on any other files. (A basic file can have it’s time stamp chaged however – think a programmer fixing a bug and saving the file).
A target is up to date if and only if all of the files it depends on are up to date (i.e., this is a recursive definition) and the time stamp of the target is greater than or equal to the time stamps of the files it depends on.


When the make command is invoked on a particular target, its job is to bring the target up to date if it isn’t already; if any of the target’s dependencies are out of date, they are brought up to date before bringing the target up to date.

Commands available in the program and associated runtime

time: This command reports the current value of the clock. Runtime: O(1)
touch [filename]: This command changes the time stamp on the specified filename to the current clock value is and increments the clock. This applies only to “basic” files; not targets with dependencies – an attempt to touch such a file should result in an error message (and the program should continue). Runtime: O(1) expected time
timestamp [filename]: This prints the time stamp on the specified file. This is the last time the file – a basic file or target – was modified. When your program begins, all files (basic and target) receive time stamps of 0. Runtime: O(1) expected time
timestamps: Prints the timestamps of all files. Runtime: O(V ) time.
make [target]: This command takes the target and brings it up to date. Basic files are always up to date. This is basically like the make command. See the text above for description. Runtime: O(V + E)
quit: quits the fakemake program

